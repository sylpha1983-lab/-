<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>表情＋エフェクト複合ビルダー（喜怒哀楽・初期クローズ／ポーズ・髪型対応）</title>
<style>
  :root{--gap:10px;--pad:10px}
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111;margin:10px}
  h1{font-size:1.15rem;margin:6px 0 12px}
  .card{padding:var(--pad);border:1px solid #eee;border-radius:12px;background:#fff;margin:10px 0}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0;flex-wrap:wrap}
  input[type="search"],input[type="text"]{width:100%;padding:.7em;border:1px solid #ccc;border-radius:10px}
  .btn{padding:.65em 1em;border:1px solid #ccc;border-radius:10px;background:#f8f8f8}
  .btn:active{transform:translateY(1px)}
  details{border:1px solid #eee;border-radius:12px;padding:6px;margin:8px 0;background:#fff}
  summary{cursor:pointer;font-weight:700;list-style:none}
  summary::-webkit-details-marker{display:none}
  label.item{display:flex;align-items:center;gap:8px;padding:6px 2px;line-height:1.25}
  .muted{color:#666}
  textarea{width:100%;min-height:140px;padding:10px;border:1px solid #ccc;border-radius:12px}
  .pill{font-size:.8rem;border:1px solid #ddd;border-radius:999px;padding:.15em .55em;background:#fafafa}
  .flex-between{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .count{font-variant-numeric:tabular-nums}
  .mono{font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;font-size:.9rem;white-space:pre-wrap}
  .ok{color:#067}.ng{color:#b00}.empty{color:#666}
</style>
</head>
<body>
  <h1>表情＋エフェクト複合ビルダー（喜怒哀楽・初期クローズ／ポーズ・髪型対応）</h1>

  <!-- 折りたためる読み込みチェッカー（UIそのまま） -->
  <div class="card">
    <details id="checkerBox">
      <summary>読み込みチェッカー： <span id="loadSummary" class="pill count">—</span></summary>
      <div id="loadLog" class="mono muted"></div>
    </details>
  </div>

  <!-- プリセット（喜怒哀楽＋heartで折りたたみ） -->
  <div class="card">
    <input id="presetSearch" type="search" placeholder="プリセット検索 / Preset search (JP/EN)">
    <details id="presetsBox">
      <summary>プリセット（✨ 喜 / 💢 怒 / 😢 哀 / 🎵 楽 / ❤️ heart・初期閉） <span id="presetCount" class="pill count"></span></summary>
      <details><summary>✨ 喜 <span id="pcJoy" class="pill count"></span></summary><div id="presetJoy"></div></details>
      <details><summary>💢 怒 <span id="pcAnger" class="pill count"></span></summary><div id="presetAnger"></div></details>
      <details><summary>😢 哀 <span id="pcSad" class="pill count"></span></summary><div id="presetSad"></div></details>
      <details><summary>🎵 楽 <span id="pcFun" class="pill count"></span></summary><div id="presetFun"></div></details>
      <details><summary>❤️ heart <span id="pcHeart" class="pill count"></span></summary><div id="presetHeart"></div></details>
      <details><summary>その他 <span id="pcOther" class="pill count"></span></summary><div id="presetOther"></div></details>
    </details>
  </div>

  <!-- 表情（喜怒哀楽＋heartで折りたたみ） -->
  <div class="card">
    <input id="exprSearch" type="search" placeholder="表情検索 / Expression search (JP/EN)">
    <details id="exprBox">
      <summary>表情（✨ 喜 / 💢 怒 / 😢 哀 / 🎵 楽 / ❤️ heart・初期閉） <span id="exprCount" class="pill count"></span></summary>
      <details><summary>✨ 喜 <span id="ecJoy" class="pill count"></span></summary><div id="exprJoy"></div></details>
      <details><summary>💢 怒 <span id="ecAnger" class="pill count"></span></summary><div id="exprAnger"></div></details>
      <details><summary>😢 哀 <span id="ecSad" class="pill count"></span></summary><div id="exprSad"></div></details>
      <details><summary>🎵 楽 <span id="ecFun" class="pill count"></span></summary><div id="exprFun"></div></details>
      <details><summary>❤️ heart <span id="ecHeart" class="pill count"></span></summary><div id="exprHeart"></div></details>
    </details>
  </div>

  <!-- エフェクト（系統ごと折りたたみ） -->
  <div class="card">
    <input id="effSearch" type="search" placeholder="エフェクト検索 / Effect search (JP/EN)">
    <details id="effBox">
      <summary>エフェクト（光／線／粒子／天候／VFX…・初期閉） <span id="effCount" class="pill count"></span></summary>
      <div id="catalogEff"></div>
    </details>
  </div>

  <!-- ポーズ（カテゴリごと折りたたみ） -->
  <div class="card">
    <input id="poseSearch" type="search" placeholder="ポーズ検索 / Pose search (JP/EN)">
    <details id="poseBox">
      <summary>ポーズ（カテゴリ別・初期閉） <span id="poseCount" class="pill count"></span></summary>
      <div id="catalogPose"></div>
    </details>
  </div>

  <!-- 髪型（カテゴリごと折りたたみ → さらに親グループで折りたたみ） -->
  <div class="card">
    <input id="hairSearch" type="search" placeholder="髪型検索 / Hair search (JP/EN)">
    <details id="hairBox">
      <summary>髪型（カテゴリ別・初期閉） <span id="hairCount" class="pill count"></span></summary>
      <div id="catalogHair"></div>
    </details>
  </div>

  <!-- Extra -->
  <div class="card">
    <details id="extraBox">
      <summary>Extra（カタログ外 / Not in catalog・初期閉） <span id="extraCount" class="pill count">0</span></summary>
      <div id="extraBody"></div>
    </details>
  </div>

  <!-- 出力 -->
  <div class="card">
    <div class="row flex-between">
      <div class="row">
        <button id="btnGen" class="btn">タグ生成</button>
        <button id="btnReset" class="btn">リセット（Extra含む）</button>
        <button id="btnCopy" class="btn">コピー</button>
      </div>
      <small class="muted">出力は英語タグ（id）をカンマ区切りで生成。UIは日英併記。</small>
    </div>
    <textarea id="out" placeholder="generated tags will appear here..."></textarea>
  </div>

<script>
/* ============================================================
   レジストリ（旧/新/別名IDすべて吸収）※UI変更なし
============================================================ */
window.__registerPromptPart = (id, data) => {
  const pb = (window.promptBuilder = window.promptBuilder || {});
  pb[id] = data;
  const alias = window.__CURRENT_LOAD_NAME;
  if (alias && !pb[alias]) pb[alias] = data;
};
window.registerPromptPart = window.__registerPromptPart;
window.__registerPromptPack = window.__registerPromptPart;

window.__registerPosePart = (id, data) => {
  const p = (window.poseBuilder = window.poseBuilder || {});
  p[id] = data;
  const alias = window.__CURRENT_LOAD_NAME;
  if (alias && !p[alias]) p[alias] = data;
};
window.__registerHairPart = (id, data) => {
  const h = (window.hairBuilder = window.hairBuilder || {});
  h[id] = data;
  const alias = window.__CURRENT_LOAD_NAME;
  if (alias && !h[alias]) h[alias] = data;
};

/* ===== 参照 ===== */
const loadLog      = document.getElementById('loadLog');
const loadSummary  = document.getElementById('loadSummary');

const presetCountEl = document.getElementById('presetCount');
const exprCountEl   = document.getElementById('exprCount');
const effCountEl    = document.getElementById('effCount');
const poseCountEl   = document.getElementById('poseCount');
const hairCountEl   = document.getElementById('hairCount');

const presetAreas = {
  joy:    document.getElementById('presetJoy'),
  anger:  document.getElementById('presetAnger'),
  sad:    document.getElementById('presetSad'),
  fun:    document.getElementById('presetFun'),
  heart:  document.getElementById('presetHeart'),
  other:  document.getElementById('presetOther'),
};
const presetAreaCounts = {
  joy: document.getElementById('pcJoy'),
  anger: document.getElementById('pcAnger'),
  sad: document.getElementById('pcSad'),
  fun: document.getElementById('pcFun'),
  heart: document.getElementById('pcHeart'),
  other: document.getElementById('pcOther'),
};

const exprAreas = {
  joy:   document.getElementById('exprJoy'),
  anger: document.getElementById('exprAnger'),
  sad:   document.getElementById('exprSad'),
  fun:   document.getElementById('exprFun'),
  heart: document.getElementById('exprHeart'),
};
const exprAreaCounts = {
  joy: document.getElementById('ecJoy'),
  anger: document.getElementById('ecAnger'),
  sad: document.getElementById('ecSad'),
  fun: document.getElementById('ecFun'),
  heart: document.getElementById('ecHeart'),
};

const catalogEffRoot  = document.getElementById('catalogEff');
const catalogPoseRoot = document.getElementById('catalogPose');
const catalogHairRoot = document.getElementById('catalogHair');

const extraBody = document.getElementById('extraBody');
const extraCount = document.getElementById('extraCount');
const out = document.getElementById('out');

const checkboxMap = new Map();
const presetBoxMap = new Map();
const extraSet = new Set();

/* ===== データ ===== */
let allCategories = [];      // Expressions + Effects
let allPresets = [];
let allPoseCategories = [];  // Poses only
let allHairCategories = [];  // Hair only

/* ===== 旧→新 変換（mix旧形式） ===== */
function convertOldExpressionEffectsToNew(obj){
  const categories = [];
  if (Array.isArray(obj.expressions) && obj.expressions.length){
    categories.push({
      name: 'Expressions / 表情',
      items: obj.expressions.map(e=>({ id: e.id, label: `${(e.jp||e.label||e.id)} / ${e.id}` }))
    });
  }
  if (Array.isArray(obj.effects) && obj.effects.length){
    const groups = {};
    obj.effects.forEach(e=>{
      const key = e.category || 'Effects / エフェクト';
      if(!groups[key]) groups[key]=[];
      groups[key].push({ id: e.id, label: `${(e.jp||e.label||e.id)} / ${e.id}` });
    });
    Object.keys(groups).forEach(k=> categories.push({ name:k, items:groups[k] }));
  }
  const presets = Array.isArray(obj.presets) ? obj.presets.map(p=>({
    id: p.id, label: p.label || p.id,
    tags: [...new Set([...(p.tags||[]), ...(p.expressions||[]), ...(p.effects||[])])]
  })) : [];
  return { categories, presets };
}

/* ===== pose/hair 正規化 ===== */
function normalizeGenericPart(data){
  if (!data) return null;
  if (Array.isArray(data.categories)) {
    data.categories.forEach(c=>{
      c.items = (c.items||[]).map(it=>({ id: it.id, label: it.label || `${it.id}` }));
    });
    return data;
  }
  if (data.name && Array.isArray(data.items)){
    return { categories:[{ name:data.name, items:data.items.map(it=>({id:it.id,label:it.label||it.id})) }] };
  }
  return null;
}

/* ===== ローディング（mix: part1-200、pose: pose_part1-200、hair: hair_part1-200） ===== */
async function loadPartsSeq(from=1,to=200){
  window.promptBuilder = window.promptBuilder || {};
  const addLog = (line,cls)=>{const d=document.createElement('div');d.textContent=line; if(cls)d.className=cls; loadLog.appendChild(d);};
  let ok=0, ng=0, empty=0;

  for (let i=from;i<=to;i++){
    const name=`part${i}`;
    try{
      if (document.getElementById(`loader-${name}`)){ ensureRegisteredMix(name)?(ok++):(empty++); addLog(`${name}: OK (cached)`,'ok'); continue; }
      const url=`${name}.js`;
      const res = await fetch(url,{cache:'no-store'});
      if (res.status===404){ empty++; addLog(`${name}: EMPTY（未配置）`,'empty'); continue; }

      const js=await res.text();
      const s=document.createElement('script');
      s.id=`loader-${name}`;
      window.__CURRENT_LOAD_NAME = name;
      s.textContent=js+`\n//# sourceURL=${url}`;
      document.head.appendChild(s);
      window.__CURRENT_LOAD_NAME = null;

      ensureRegisteredMix(name)?(ok++):(empty++, addLog(`${name}: EMPTY（ファイルは読めたが未登録）`,'empty')); 
    }catch(e){ ng++; addLog(`${name}: ERROR ${e.message}`,'ng'); }
  }
  loadSummary.dataset.mixOk = ok;
  loadSummary.dataset.mixNg = ng;
  loadSummary.dataset.mixEmpty = empty;
  updateLoadSummary();
}

async function loadPoseSeq(from=1,to=200){
  window.poseBuilder = window.poseBuilder || {};
  const addLog = (line,cls)=>{const d=document.createElement('div');d.textContent=line; if(cls)d.className=cls; loadLog.appendChild(d);};
  let ok=0, ng=0, empty=0;

  for (let i=from;i<=to;i++){
    const id=`pose_part${i}`;
    try{
      if (document.getElementById(`loader-${id}`)){ ensureRegisteredPose(id)?(ok++):(empty++); addLog(`${id}: OK (cached)`,'ok'); continue; }
      const url=`${id}.js`;
      const res=await fetch(url,{cache:'no-store'});
      if (res.status===404){ empty++; addLog(`${id}: EMPTY（未配置）`,'empty'); continue; }

      const js=await res.text();
      const s=document.createElement('script');
      s.id=`loader-${id}`;
      window.__CURRENT_LOAD_NAME = id;
      s.textContent=js+`\n//# sourceURL=${url}`;
      document.head.appendChild(s);
      window.__CURRENT_LOAD_NAME = null;

      ensureRegisteredPose(id)?(ok++):(empty++, addLog(`${id}: EMPTY（ファイルは読めたが未登録）`,'empty'));
    }catch(e){ ng++; addLog(`${id}: ERROR ${e.message}`,'ng'); }
  }
  loadSummary.dataset.poseOk = ok;
  loadSummary.dataset.poseNg = ng;
  loadSummary.dataset.poseEmpty = empty;
  updateLoadSummary();
}

async function loadHairSeq(from=1,to=200){
  window.hairBuilder = window.hairBuilder || {};
  const addLog = (line,cls)=>{const d=document.createElement('div');d.textContent=line; if(cls)d.className=cls; loadLog.appendChild(d);};
  let ok=0, ng=0, empty=0;

  for (let i=from;i<=to;i++){
    const id=`hair_part${i}`;
    try{
      if (document.getElementById(`loader-${id}`)){ ensureRegisteredHair(id)?(ok++):(empty++); addLog(`${id}: OK (cached)`,'ok'); continue; }
      const url=`${id}.js`;
      const res=await fetch(url,{cache:'no-store'});
      if (res.status===404){ empty++; addLog(`${id}: EMPTY（未配置）`,'empty'); continue; }

      const js=await res.text();
      const s=document.createElement('script');
      s.id=`loader-${id}`;
      window.__CURRENT_LOAD_NAME = id;
      s.textContent=js+`\n//# sourceURL=${url}`;
      document.head.appendChild(s);
      window.__CURRENT_LOAD_NAME = null;

      ensureRegisteredHair(id)?(ok++):(empty++, addLog(`${id}: EMPTY（ファイルは読めたが未登録）`,'empty'));
    }catch(e){ ng++; addLog(`${id}: ERROR ${e.message}`,'ng'); }
  }
  loadSummary.dataset.hairOk = ok;
  loadSummary.dataset.hairNg = ng;
  loadSummary.dataset.hairEmpty = empty;
  updateLoadSummary();
}

function updateLoadSummary(){
  const mixOk=Number(loadSummary.dataset.mixOk||0),
        mixNg=Number(loadSummary.dataset.mixNg||0),
        mixEm=Number(loadSummary.dataset.mixEmpty||0),
        poseOk=Number(loadSummary.dataset.poseOk||0),
        poseNg=Number(loadSummary.dataset.poseNg||0),
        poseEm=Number(loadSummary.dataset.poseEmpty||0),
        hairOk=Number(loadSummary.dataset.hairOk||0),
        hairNg=Number(loadSummary.dataset.hairNg||0),
        hairEm=Number(loadSummary.dataset.hairEmpty||0);
  loadSummary.textContent = `mix: 成功${mixOk}/失敗${mixNg}/空${mixEm} ｜ pose: 成功${poseOk}/失敗${poseNg}/空${poseEm} ｜ hair: 成功${hairOk}/失敗${hairNg}/空${hairEm}`;
}

/* ===== ensure（登録確認） ===== */
function ensureRegisteredMix(name){
  if (window.promptBuilder && window.promptBuilder[name]) return true;
  if (window.expressionEffects && window.expressionEffects[name]){
    window.promptBuilder[name] = convertOldExpressionEffectsToNew(window.expressionEffects[name]);
    return true;
  }
  const maybe = window[name];
  if (maybe && (maybe.categories || maybe.expressions || maybe.effects)){
    window.promptBuilder[name] = maybe.categories ? maybe : convertOldExpressionEffectsToNew(maybe);
    return true;
  }
  return false;
}
function ensureRegisteredPose(id){
  if (window.poseBuilder && window.poseBuilder[id]) return true;
  if (window[id]){ const norm=normalizeGenericPart(window[id]); if (norm){ window.poseBuilder[id]=norm; return true; } }
  if (window.poseParts && window.poseParts[id]){ const norm=normalizeGenericPart(window.poseParts[id]); if (norm){ window.poseBuilder[id]=norm; return true; } }
  return false;
}
function ensureRegisteredHair(id){
  if (window.hairBuilder && window.hairBuilder[id]) return true;
  if (window[id]){ const norm=normalizeGenericPart(window[id]); if (norm){ window.hairBuilder[id]=norm; return true; } }
  if (window.hairParts && window.hairParts[id]){ const norm=normalizeGenericPart(window.hairParts[id]); if (norm){ window.hairBuilder[id]=norm; return true; } }
  return false;
}

/* ===== 統合 ===== */
function integrateMix(){
  const parts = window.promptBuilder || {};
  const catMap = new Map();
  const presetArr = [];

  Object.keys(parts).sort().forEach(k=>{
    const p = parts[k]||{};
    (p.categories||[]).forEach(cat=>{
      if (!cat || !cat.name) return;
      const name = cat.name;
      if (!catMap.has(name)) catMap.set(name,{name,items:[]});
      const bucket = catMap.get(name);
      (cat.items||[]).forEach(it=>{
        if (!it || !it.id) return;
        if (!bucket.items.some(x=>x.id===it.id)){
          bucket.items.push({id: it.id, label: it.label || it.id});
        }
      });
    });
    (p.presets||[]).forEach(pr=>{
      if (!pr || !pr.id) return;
      let tags = [];
      if (Array.isArray(pr.tags))        tags = tags.concat(pr.tags);
      if (Array.isArray(pr.expressions)) tags = tags.concat(pr.expressions);
      if (Array.isArray(pr.effects))     tags = tags.concat(pr.effects);
      tags = [...new Set(tags.filter(Boolean))];
      presetArr.push({id: pr.id, label: pr.label || pr.id, tags});
    });
  });

  allCategories = [...catMap.values()];
  allCategories.sort((a,b)=>{
    const ae = a.name.startsWith('Expressions') ? 0 : 1;
    const be = b.name.startsWith('Expressions') ? 0 : 1;
    return ae-be || a.name.localeCompare(b.name);
  });
  allPresets = presetArr;
}

function integratePose(){
  const parts = window.poseBuilder || {};
  const catMap = new Map();
  Object.keys(parts).sort().forEach(k=>{
    (parts[k].categories||[]).forEach(cat=>{
      if (!cat || !cat.name) return;
      if (!catMap.has(cat.name)) catMap.set(cat.name,{name:cat.name,items:[]});
      const b=catMap.get(cat.name);
      (cat.items||[]).forEach(it=>{
        if (it && it.id && !b.items.some(x=>x.id===it.id)){
          b.items.push({id:it.id,label:it.label||it.id});
        }
      });
    });
  });
  allPoseCategories = [...catMap.values()].sort((a,b)=>a.name.localeCompare(b.name));
}
function integrateHair(){
  const parts = window.hairBuilder || {};
  const catMap = new Map();
  Object.keys(parts).sort().forEach(k=>{
    (parts[k].categories||[]).forEach(cat=>{
      if (!cat || !cat.name) return;
      if (!catMap.has(cat.name)) catMap.set(cat.name,{name:cat.name,items:[]});
      const b=catMap.get(cat.name);
      (cat.items||[]).forEach(it=>{
        if (it && it.id && !b.items.some(x=>x.id===it.id)){
          b.items.push({id:it.id,label:it.label||it.id});
        }
      });
    });
  });
  allHairCategories = [...catMap.values()].sort((a,b)=>a.name.localeCompare(b.name));
}

/* ===== 髪型の“もう一段折りたたみ”用グループ判定 ===== */
function hairGroupName(name){
  const n = (name||'').toLowerCase();
  if (/ponytail/.test(n)) return 'Ponytails / ポニーテール系';
  if (/color|colors|カラー/.test(n)) return 'Colors / カラー系';
  if (/highlight|mesh|gradation|gradient|two[- ]?tone|neon|glow|グラデ|ハイライト|ツートーン|発光/.test(n))
    return 'Highlights & Gradations / ハイライト・グラデ系';
  if (/bangs|long|short|medium|updo|style|スタイル|前髪|ロング|ショート|ミディアム|まとめ|巻き|アップ/.test(n))
    return 'Styles / スタイル系';
  if (/accessor|飾|アクセ/.test(n)) return 'Accessories / アクセ系';
  if (/traditional|ethnic|cultural|和|民族|伝統|文化/.test(n))
    return 'Traditional & Cultural / 伝統・文化系';
  if (/fantasy|magic|gothic|dark|otherworld|futur|sci[- ]?fi|cyber|sf|異世界|未来|幻想|魔法|ゴシック|ダーク/.test(n))
    return 'Fantasy / Sci-Fi / Gothic';
  return 'Other / その他';
}

/* ===== UI構築 ===== */
function moodBucketOf(label){
  const raw=(label||'');
  const s=raw.toLowerCase();
  if (/(heart|ハート|❤️)/i.test(raw)) return 'heart';
  if (/(喜|安堵|微笑|星|雪|光)/.test(raw)||/(joy|reliev|cheer|spark)/.test(s)) return 'joy';
  if (/(怒|決意|嵐|雷|砂|熱)/.test(raw)||/(storm|thunder|gust|scorch|resolve)/.test(s)) return 'anger';
  if (/(哀|静謐|涙|寂)/.test(raw)||/(melan|quiet|calm|serene)/.test(s)) return 'sad';
  if (/(楽|遊|戯|泡|きら)/.test(raw)||/(fun|play|bubble|sparkle)/.test(s)) return 'fun';
  return 'fun';
}

function buildPresets(){
  Object.values(presetAreas).forEach(el=> el && (el.innerHTML=''));
  presetBoxMap.clear();

  allPresets.forEach(p=>{
    const bucket = moodBucketOf(p.label);
    const area = presetAreas[bucket] || presetAreas.other;
    const lab = document.createElement('label'); lab.className='item';
    const cb  = document.createElement('input'); cb.type='checkbox'; cb.dataset.pid = p.id;
    lab.appendChild(cb);
    lab.appendChild(document.createTextNode(`${p.label} / ${p.id}`));
    area.appendChild(lab);
    presetBoxMap.set(p.id, cb);
    cb.addEventListener('change', ()=> applyPreset(p, cb.checked));
  });

  const counts = {joy:0,anger:0,sad:0,fun:0,heart:0,other:0};
  allPresets.forEach(p=> counts[moodBucketOf(p.label)] = (counts[moodBucketOf(p.label)]||0)+1);
  presetAreaCounts.joy.textContent    = counts.joy;
  presetAreaCounts.anger.textContent  = counts.anger;
  presetAreaCounts.sad.textContent    = counts.sad;
  presetAreaCounts.fun.textContent    = counts.fun;
  presetAreaCounts.heart.textContent  = counts.heart;
  presetAreaCounts.other.textContent  = counts.other;
  presetCountEl.textContent = `全${allPresets.length}`;
}

function buildExpressionsByMood(){
  Object.values(exprAreas).forEach(el=> el && (el.innerHTML=''));
  const exprCat = allCategories.find(c=>c.name.startsWith('Expressions'));
  const items = exprCat?.items || [];
  let counts = {joy:0,anger:0,sad:0,fun:0,heart:0};
  items.forEach(it=>{
    const bucket = moodBucketOf(it.label||it.id);
    const area = exprAreas[bucket] || exprAreas.fun;
    const lab = document.createElement('label'); lab.className='item';
    const cb  = document.createElement('input'); cb.type='checkbox';
    cb.dataset.id = it.id; cb.value = it.id;
    lab.appendChild(cb);
    lab.appendChild(document.createTextNode(`${it.label || it.id} / ${it.id}`));
    area.appendChild(lab);
    checkboxMap.set(it.id, cb);
    cb.addEventListener('change', syncPresetsFromCatalog);
    counts[bucket] = (counts[bucket]||0)+1;
  });
  exprCountEl.textContent = `全${items.length}`;
  exprAreaCounts.joy.textContent   = counts.joy||0;
  exprAreaCounts.anger.textContent = counts.anger||0;
  exprAreaCounts.sad.textContent   = counts.sad||0;
  exprAreaCounts.fun.textContent   = counts.fun||0;
  exprAreaCounts.heart.textContent = counts.heart||0;
}

function buildEffects(){
  catalogEffRoot.innerHTML='';
  allCategories.filter(c=>!c.name.startsWith('Expressions')).forEach(cat=>{
    const wrap=document.createElement('details'); wrap.open=false;
    const sum=document.createElement('summary'); sum.textContent=cat.name;
    wrap.appendChild(sum);
    (cat.items||[]).forEach(it=>{
      const lab=document.createElement('label'); lab.className='item';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.dataset.id=it.id; cb.value=it.id;
      lab.appendChild(cb);
      lab.appendChild(document.createTextNode(`${it.label || it.id} / ${it.id}`));
      wrap.appendChild(lab);
      checkboxMap.set(it.id, cb);
      cb.addEventListener('change', syncPresetsFromCatalog);
    });
    catalogEffRoot.appendChild(wrap);
  });
  const effItems = allCategories.filter(c=>!c.name.startsWith('Expressions')).reduce((n,c)=>n+(c.items?.length||0),0);
  effCountEl.textContent = `全${effItems}`;
}

function buildPoses(){
  catalogPoseRoot.innerHTML='';
  allPoseCategories.forEach(cat=>{
    const wrap=document.createElement('details'); wrap.open=false;
    const sum=document.createElement('summary'); sum.textContent=cat.name;
    wrap.appendChild(sum);
    (cat.items||[]).forEach(it=>{
      const lab=document.createElement('label'); lab.className='item';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.dataset.id=it.id; cb.value=it.id;
      lab.appendChild(cb);
      lab.appendChild(document.createTextNode(`${it.label || it.id} / ${it.id}`));
      wrap.appendChild(lab);
      checkboxMap.set(it.id, cb);
      cb.addEventListener('change', syncPresetsFromCatalog);
    });
    catalogPoseRoot.appendChild(wrap);
  });
  const total = allPoseCategories.reduce((n,c)=>n+(c.items?.length||0),0);
  poseCountEl.textContent = `全${total}`;
}

/* ★★★ 髪型：もう一段の折りたたみ（グループ→カテゴリ→タグ） ★★★ */
function buildHair(){
  catalogHairRoot.innerHTML='';

  // 1) カテゴリをグループ名にマップ
  const groupMap = new Map(); // groupName -> { wrap, inner, count }
  function ensureGroup(name){
    if (!groupMap.has(name)){
      const gWrap = document.createElement('details'); gWrap.open=false;
      const gSum  = document.createElement('summary'); gSum.textContent = name + ' ';
      const gCnt  = document.createElement('span'); gCnt.className='pill count'; gCnt.textContent='0';
      gSum.appendChild(gCnt);
      gWrap.appendChild(gSum);
      const gBody = document.createElement('div');
      gWrap.appendChild(gBody);
      catalogHairRoot.appendChild(gWrap);
      groupMap.set(name,{wrap:gWrap, body:gBody, cnt:gCnt, num:0});
    }
    return groupMap.get(name);
  }

  // 2) 各カテゴリをグループ内の details として作成
  allHairCategories.forEach(cat=>{
    const gName = hairGroupName(cat.name);
    const g = ensureGroup(gName);
    const wrap=document.createElement('details'); wrap.open=false;
    const sum=document.createElement('summary'); sum.textContent=cat.name;
    wrap.appendChild(sum);

    (cat.items||[]).forEach(it=>{
      const lab=document.createElement('label'); lab.className='item';
      const cb=document.createElement('input'); cb.type='checkbox';
      cb.dataset.id=it.id; cb.value=it.id;
      lab.appendChild(cb);
      lab.appendChild(document.createTextNode(`${it.label || it.id} / ${it.id}`));
      wrap.appendChild(lab);
      checkboxMap.set(it.id, cb);
      cb.addEventListener('change', syncPresetsFromCatalog);
    });

    g.body.appendChild(wrap);
    g.num += 1;
  });

  // 3) グループの件数バッジを更新
  groupMap.forEach(g=> g.cnt.textContent = g.num);

  // 合計件数（従来通り：項目総数）
  const total = allHairCategories.reduce((n,c)=>n+(c.items?.length||0),0);
  hairCountEl.textContent = `全${total}`;
}

/* ===== Extra / プリセット連動 / 検索 / 出力 ===== */
function addExtra(id,label){
  if (checkboxMap.has(id) || extraSet.has(id)) return;
  extraSet.add(id);
  const labEl = document.createElement('label'); labEl.className='item';
  const cbox  = document.createElement('input'); cbox.type='checkbox';
  cbox.checked = true; cbox.dataset.id=id; cbox.value=id; cbox.dataset.extra='1';
  labEl.appendChild(cbox);
  labEl.appendChild(document.createTextNode(label?`${label} / ${id}`:id));
  extraBody.appendChild(labEl);
  extraCount.textContent = String(extraSet.size);
}
function applyPreset(p,checked){
  const ids=(p.tags||[]).filter(Boolean);
  ids.forEach(id=>{
    const t=checkboxMap.get(id);
    if (t){ t.checked=checked; t.dispatchEvent(new Event('change',{bubbles:false})); }
    else if (checked){ addExtra(id); }
    else{
      const box=[...extraBody.querySelectorAll('input[type=checkbox]')].find(x=>x.dataset.id===id);
      if (box) box.checked=false;
    }
  });
  syncPresetsFromCatalog();
}
function filterList(rootEl,q){
  const qq=(q||'').trim().toLowerCase();
  rootEl.querySelectorAll('label.item').forEach(l=>{
    l.style.display = l.textContent.toLowerCase().includes(qq) ? '' : 'none';
  });
}
document.getElementById('presetSearch').addEventListener('input',e=>{
  filterList(document.getElementById('presetsBox'), e.target.value);
});
document.getElementById('exprSearch').addEventListener('input',e=>{
  filterList(document.getElementById('exprBox'), e.target.value);
});
document.getElementById('effSearch').addEventListener('input',e=>{
  filterList(document.getElementById('effBox'), e.target.value);
});
document.getElementById('poseSearch').addEventListener('input',e=>{
  filterList(document.getElementById('poseBox'), e.target.value);
});
document.getElementById('hairSearch').addEventListener('input',e=>{
  filterList(document.getElementById('hairBox'), e.target.value);
});
function syncPresetsFromCatalog(){
  allPresets.forEach(p=>{
    const ids=p.tags||[]; let checked=0, known=0;
    ids.forEach(id=>{
      const box=checkboxMap.get(id);
      if (box){ known++; if (box.checked) checked++; }
      else if (extraSet.has(id)){ known++; checked++; }
    });
    const cb=presetBoxMap.get(p.id); if(!cb) return;
    if (checked===0){ cb.checked=false; cb.indeterminate=false; }
    else if (checked===known && known>0){ cb.checked=true; cb.indeterminate=false; }
    else { cb.checked=false; cb.indeterminate=true; }
  });
}
function generateTags(){
  const ids=[];
  checkboxMap.forEach((cb,id)=>{ if (cb.checked) ids.push(id); });
  extraBody?.querySelectorAll('input[type=checkbox]:checked').forEach(cb=>{
    const id=cb.dataset.id||cb.value||''; if(id) ids.push(id);
  });
  out.value = ids.filter(Boolean).join(', ');
}
function resetAll(){
  checkboxMap.forEach(cb=> cb.checked=false);
  presetBoxMap.forEach(cb=> { cb.checked=false; cb.indeterminate=false; });
  extraSet.clear(); extraBody.innerHTML=''; extraCount.textContent='0'; out.value='';
}
document.getElementById('btnGen').addEventListener('click', generateTags);
document.getElementById('btnReset').addEventListener('click', resetAll);
document.getElementById('btnCopy').addEventListener('click', ()=> navigator.clipboard.writeText(out.value));

/* ===== 初期化（UIは初期クローズ維持） ===== */
(async function init(){
  loadLog.textContent = '';
  await loadPartsSeq(1,200);   // mix
  await loadPoseSeq(1,200);    // pose
  await loadHairSeq(1,200);    // hair
  integrateMix();
  integratePose();
  integrateHair();
  buildPresets();
  buildExpressionsByMood();
  buildEffects();
  buildPoses();
  buildHair();
  document.querySelectorAll('details').forEach(d=> d.open=false);
})();
</script>
</body>
</html>