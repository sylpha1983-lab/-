// ext_i18n_tooltip.js
// Output "meaning tooltip" for prompt tokens in #out.
// - Does NOT rewrite #out contents.
// - Uses i18n locale packs (ja) generated by Pick.
// - Patches core's __outputTranslation.toggle() into "output guide" switch.
//
// Works on mobile: tap a token inside #out => tooltip shows Japanese meaning.

(function(){
  "use strict";

  function $(sel){ return document.querySelector(sel); }

  // --- utilities copied from ext_i18n_capture.js (keep keys stable) ---
  function simpleHash(str) {
    // Non-crypto, stable for a given string (FNV-1a 32bit)
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(16);
  }

  function parsePromptLemma(rawToken) {
    let t = (rawToken || "").trim();
    t = t.replace(/^[\s,]+|[\s,]+$/g, "");
    const wrapMatch = t.match(/^(\(+|\{+|\[+)\s*([\s\S]*?)\s*(\)+|\}+|\]+)$/);
    if (wrapMatch) t = wrapMatch[2].trim();
    const w = t.match(/^(.*?)(?::|::)\s*(-?\d+(?:\.\d+)?)$/);
    if (w) t = w[1].trim();
    t = t.toLowerCase().replace(/\s+/g, " ").trim();
    return t;
  }

  function tokenAt(text, pos){
    if (!text) return "";
    const seps = /[,，、\n]/;
    let l = pos, r = pos;
    while (l > 0 && !seps.test(text[l-1])) l--;
    while (r < text.length && !seps.test(text[r])) r++;
    return text.slice(l, r).trim();
  }

  // --- tooltip UI ---
  let tipEl = null;
  let tipTimer = null;

  function ensureTip(){
    if (tipEl) return tipEl;
    tipEl = document.createElement("div");
    tipEl.id = "__i18n_out_tip";
    tipEl.style.cssText = [
      "position:fixed",
      "z-index:9998",
      "max-width:72vw",
      "padding:10px 12px",
      "border-radius:12px",
      "background:rgba(20,20,20,0.92)",
      "color:#fff",
      "font-size:14px",
      "line-height:1.35",
      "box-shadow:0 10px 28px rgba(0,0,0,0.35)",
      "pointer-events:none",
      "opacity:0",
      "transform:translateY(6px)",
      "transition:opacity 140ms ease, transform 140ms ease"
    ].join(";");
    document.body.appendChild(tipEl);
    return tipEl;
  }

  function showTip(x, y, raw, ja){
    const el = ensureTip();
    const safeRaw = String(raw || "").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    const safeJa  = String(ja || "").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    el.innerHTML = '<div style="opacity:.9;font-weight:600;">' + safeRaw +
      '</div><div style="opacity:.35;margin:6px 0;border-top:1px solid rgba(255,255,255,.22);"></div>' +
      '<div style="opacity:1;">' + safeJa + '</div>';

    // Place near tap, but keep inside viewport
    const pad = 10;
    el.style.left = pad + "px";
    el.style.top = pad + "px";
    el.style.opacity = "0";
    el.style.transform = "translateY(6px)";

    // measure
    requestAnimationFrame(() => {
      const rect = el.getBoundingClientRect();
      let left = x - rect.width / 2;
      let top  = y - rect.height - 14;

      if (left < pad) left = pad;
      if (left + rect.width > window.innerWidth - pad) left = window.innerWidth - rect.width - pad;
      if (top < pad) top = y + 14; // if no space above, put below

      el.style.left = left + "px";
      el.style.top  = top + "px";
      el.style.opacity = "1";
      el.style.transform = "translateY(0)";
    });

    if (tipTimer) clearTimeout(tipTimer);
    tipTimer = setTimeout(() => {
      if (!tipEl) return;
      tipEl.style.opacity = "0";
      tipEl.style.transform = "translateY(6px)";
    }, 1800);
  }

  function getJaByLemma(lemma){
    if (!lemma) return "";
    const key = "prompt.token." + simpleHash("v1|" + lemma).slice(0, 8);
    // Prefer direct dict access to avoid returning the key itself
    const dicts = (window.__i18n && window.__i18n.dicts) ? window.__i18n.dicts : null;
    const jaDict = dicts && dicts["ja"] ? dicts["ja"] : null;
    if (jaDict && Object.prototype.hasOwnProperty.call(jaDict, key)) return jaDict[key] || "";
    return "";
  }

  function setGuideButtonText(){
    const btn = document.getElementById("translateBtn");
    if (!btn) return;
    const on = !!window.__I18N_OUTPUT_GUIDE;
    btn.textContent = on ? "訳ガイド✓" : "訳ガイド";
  }

  function patchToggle(){
    // Core calls: window.__outputTranslation.toggle()
    if (!window.__outputTranslation || window.__outputTranslation.__yakuguidPatched) return;
    window.__outputTranslation.__yakuguidPatched = true;

    window.__I18N_OUTPUT_GUIDE = !!window.__I18N_OUTPUT_GUIDE;

    // Replace toggle with "guide switch" (no rewrite)
    window.__outputTranslation.toggle = function(){
      window.__I18N_OUTPUT_GUIDE = !window.__I18N_OUTPUT_GUIDE;
      setGuideButtonText();
      try {
        document.dispatchEvent(new CustomEvent("i18n:outputGuideToggle", { detail: { enabled: window.__I18N_OUTPUT_GUIDE } }));
      } catch(e){}
    };

    setGuideButtonText();
  }

  function bindOutTap(){
    const outEl = document.getElementById("out");
    if (!outEl || outEl.__i18nTipBound) return;
    outEl.__i18nTipBound = true;

    // Use pointerup for mobile taps
    outEl.addEventListener("pointerup", (ev) => {
      if (!window.__I18N_OUTPUT_GUIDE) return;

      // On mobile, selectionStart is updated *after* pointerup in many browsers.
      // Defer reading the caret position to the next tick to get the correct token.
      setTimeout(() => {
        try { outEl.focus && outEl.focus(); } catch(_) {}
        const text = outEl.value || "";
        const pos = (typeof outEl.selectionStart === "number") ? outEl.selectionStart : 0;
        const raw = tokenAt(text, pos);
        if (!raw) return;

        const lemma = parsePromptLemma(raw);
        const ja = getJaByLemma(lemma);
        if (!ja) return;

        const x = (ev.clientX || (ev.touches && ev.touches[0] && ev.touches[0].clientX) || (window.innerWidth/2));
        const y = (ev.clientY || (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 60);
        showTip(x, y, lemma, ja);
      }, 0);
    }, { passive: true });
  }


  function boot(){
    patchToggle();
    bindOutTap();

    // in case core mounts later or DOM re-renders, retry a bit
    let tries = 0;
    const t = setInterval(() => {
      tries++;
      patchToggle();
      bindOutTap();
      if (tries > 50) clearInterval(t);
    }, 200);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();
